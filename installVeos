#!/usr/bin/python2
# Copyright (c) 2016 Arista Networks, Inc.  All rights reserved.
# Arista Networks, Inc. Confidential and Proprietary.

import subprocess
from subprocess import check_output, call, CalledProcessError, Popen, PIPE
import re, os, sys

libvirtTemplate = '''
<domain type='kvm'>
  <name>%s</name>
  <memory unit='MiB'>4096</memory>
  <currentMemory unit='MiB'>4096</currentMemory>
  <vcpu placement='static'>2</vcpu>
  <resource>
    <partition>/machine</partition>
  </resource>
  <cpu mode='host-model'/>
  <os>
    <type arch='x86_64' machine='pc'>hvm</type>
    <boot dev='hd'/>
  </os>
  <features>
    <acpi/>
    <apic/>
    <pae/>
  </features>
  <clock offset='utc'/>
  <on_poweroff>destroy</on_poweroff>
  <on_reboot>restart</on_reboot>
  <on_crash>restart</on_crash>
  <devices>
    <emulator>%s</emulator>
    <disk type='file' device='disk'>
      <driver name='qemu' type='qcow2' cache='directsync'/>
      <source file="%s"/>
      <target dev='hda' bus='ide'/>
      <alias name='ide0-0-0'/>
      <address type='drive' controller='0' bus='0' target='0' unit='0'/>
    </disk>
    <controller type='usb' index='0'>
      <alias name='usb0'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x01' function='0x2'/>
    </controller>
    <controller type='pci' index='0' model='pci-root'>
      <alias name='pci0'/>
    </controller>
    <controller type='ide' index='0'>
      <alias name='ide0'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x01' function='0x1'/>
    </controller>
    <serial type='pty'>
      <source path='/dev/pts/4'/>
      <target port='0'/>
      <alias name='serial0'/>
    </serial>
    <console type='pty' tty='/dev/pts/4'>
      <source path='/dev/pts/4'/>
      <target type='serial' port='0'/>
      <alias name='serial0'/>
    </console>
    <input type='mouse' bus='ps2'/>
    <graphics type='vnc' port='5903' autoport='yes' listen='127.0.0.1'>
      <listen type='address' address='127.0.0.1'/>
    </graphics>
    <video>
      <model type='cirrus' vram='9216' heads='1'/>
      <alias name='video0'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x0'/>
    </video>
    <memballoon model='virtio'>
      <alias name='balloon0'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x04' function='0x0'/>
    </memballoon>
  </devices>
</domain>
'''

libvirtInterfaceTemplate  = '''
    <interface type='bridge'>
      <source bridge='%s'/>
      <model type='virtio'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='%d' function='0x0'/>
    </interface>'''

libvirtNetworkTemplate = '''
<network>
  <name>%s</name>
  <bridge name='%s' stp='off'/>
</network>
'''
def runCmd ( cmd, suppress=False ):
      p = Popen(cmd, stdout=PIPE, stderr=PIPE)
      stdout, stderr = p.communicate()
      if not suppress and stderr:
         if "already" not in stderr:
            cmdAsString = ""
            for arg in cmd:
               cmdAsString += ' ' + arg
               print "Warning : Could not execute " + cmdAsString
            print stderr
      return stdout, stderr

def cmdOutput ( cmd ):
   stdout, _ = runCmd( cmd, suppress=True )
   return stdout

def checkCmd( cmd, substring, errSubString=None ):
   stdout, stderr = runCmd( cmd, suppress=True )
   if errSubString == None:
      return substring in stdout
   else:
      return errSubString in stderr

def checkIntelVt():
   if not checkCmd( ["cat", "/proc/cpuinfo"], "vmx" ):
      sys.exit( "CPU does not support VT-x hardware virtualization. " +
                "Cannot run vEOS..exiting" )

def getDriverInfo( device, info ):
   output = cmdOutput( ["ethtool", "-i", device] )
   if output is not None:
      pat = re.compile( info + ": (.*)")
      m = pat.search( output )
      if m is not None:
         return m.group(1)
   return None

def checkIommuOn():
   if not checkCmd( ["cat", "/proc/cmdline"], "intel_iommu=on" ):
      print "Enabling IOMMU. Need to reboot server for changes to take effect"
      print "Please rerun setup once system reboots to continue"
      return False
   return True

def checkLibvirt():
   if checkCmd( ["virsh", "list"], "Failed to reconnect to the hypervisor" ):
      sys.exit( "libvirtd is not running" )

class EthModel:
   Unknown    = 1
   Intel82599 = 2
   Intelx540  = 3

class Speed:
   Unknown    = 1
   Gigabit    = 2
   TenGigabit = 3

class DeviceType:
   Unknown    = 1
   Ethernet   = 2
   Bridge     = 3
   Tap        = 4

class EthDevice:
   def __init__( self, name, driver ):
      self.name   = name
      self.driver = driver
      self.model  = EthModel.Unknown
      self.speed  =  Speed.Unknown

class Devices:
   def __init__( self ):
      self.devices = []
      self.ethDevices = []
      self.bridgeDevices = []
      self.sriovDevices = []

      ## get all links and figure out the ethernet interfaces
      devices = re.findall( "\d+: (\S+):", cmdOutput( ["ip", "link"] ) )
      ## remove loopback intfs
      self.devices = [link for link in devices if not re.match( '^lo', link )]

      for device in self.devices:
         driver = getDriverInfo( device, "driver" )
         # print "device %s driver %s" % ( device, driver )
         if driver == 'tap' or driver == "tun" :
            continue
         elif driver == 'bridge':
            self.bridgeDevices.append( device )
         else:
            # assume ethernet device
            self.ethDevices.append( EthDevice( device, driver ) )

   def getEthDeviceNames( self ):
      return [dev.name for dev in self.ethDevices]

def askQ( question ):
   while True:
      ans = raw_input( question + " (y/n)? ")
      if ans == 'y' or ans == 'n':
         return ans == 'y'
      print "Invalid input. You entered : " + ans

def validated_input( prompt, min_=None, max_=None ):
    while True:
        ui = raw_input( prompt )
        try:
           ui = int(ui)
        except ValueError:
           print("Input type must be {0}.".format(int.__name__))
           continue
        if max_ is not None and ui > max_:
            print( "Input must be less than or equal to {0}.".format( max_ ) )
        elif min_ is not None and ui < min_:
            print( "Input must be greater than or equal to {0}.".format( min_ ) )
        else:
            return ui

def createBridge( network ):
   networkDef = libvirtNetworkTemplate % ( network, network )
   networkTemplateFile = "/tmp/" + network
   getVmCmd = "echo \"" + networkDef + "\" > " + networkTemplateFile
   os.system( getVmCmd )
   runCmd( ["virsh", "net-define", networkTemplateFile] )
   getVmCmd = "virsh net-start " + network
   runCmd( ["virsh", "net-start", network] )
   getVmCmd = "virsh net-autostart " + network
   runCmd( ["virsh", "net-autostart", network] )
   os.remove( networkTemplateFile )
   return network

def createBridges( vmName, networks, noNetworks ):
   netName = vmName + '-net'
   for i, network in enumerate( networks ):
      if network == 'new':
         networks[ i ] = createBridge( netName + str( i ) )
      else:
         createBridge( network )

def getPortsOnBridge( bridge ):
   out = cmdOutput( ["brctl", "show", bridge] )
   out = out.rstrip('\n').split()
   if len( out ) > 10:
      return out[10:]
   else:
      return None

def getPhyPortsOnBridge( bridge ):
   ethDevs = devices.getEthDeviceNames()
   bridgePorts = getPortsOnBridge( bridge )
   if bridgePorts:
      return list( set( bridgePorts ).intersection( ethDevs ) )
   else:
      return None

def getFreePhyPorts():
   usedPorts = []
   for bridge in devices.bridgeDevices:
      freePhyPorts = getPhyPortsOnBridge( bridge )
      if freePhyPorts:
         usedPorts = usedPorts + freePhyPorts
   return list( set( devices.getEthDeviceNames() ) - set( usedPorts ) )

def getBridge( port ):
   for bridge in devices.bridgeDevices:
      if port in getPortsOnBridge( bridge):
         return bridge
   return None

def addPortToBridge( port, bridge ):
   runCmd( ["brctl", "addif", bridge, port] )

def printList( pylist ):
   print ' '.join( pylist )

def setupPnic( bridge, ports ):
   print "Avail ports : "
   printList( ports )
   print "Enter the name of the physical nic for bridge %s" % bridge
   while True:
      port = raw_input( "Enter port : " )
      if port not in ports:
         print "Invalid port name ", port
      else:
         break
   addPortToBridge( port, bridge )
   return

def setupNetworks( vmName ):
   noInterfaces = validated_input( "Enter the number of virtual ethernet " + \
                                   "interfaces in addition to ma1 interface" + \
                                   "? (max = 8) : " , 0, 8 )
   bridges = []
   newBridges = []
   intfs = ['Management1'] + [
         'Ethernet' + str( i ) for i in range( 1, noInterfaces + 1 )]
   startNet = 0
   # It is recommended not to have other ports connected to bridge xyz
   # Currently ethernet1 is connected to WAN and ethernet2 to LAN
   print "vEOS interfaces that need to be networked:"
   printList( intfs )
   availBridges = devices.bridgeDevices
   for i, intf in enumerate( intfs ):
      print "\nSetting up %s" % intf
      if askQ( "Do you want to use an existing bridge "):
         print "Existing bridges :"
         printList( availBridges )
         while True:
            bridge = raw_input( "Enter bridge to connect interface %s : "  % intf )
            if bridge in availBridges:
               availBridges.remove( bridge )
               break
            print "Entered non existing bridge ", bridge
         bridges.append( bridge )
      else:
         bridge = raw_input( "Enter name of the new bridge or hit enter to"
                             " create with default name : " )
         if not bridge:
            bridge = vmName + '-net' + str( i )
         createBridge( bridge )
         bridges.append( bridge )
      freePhyPorts = getFreePhyPorts()
   print "\nvEOS connections setup:"
   intfs = ['Management1'] + \
           ['Ethernet' + str( i ) for i in range( 1, noInterfaces + 1 )]
   for intf, bridge in zip( intfs, bridges ):
         print intf + '  <-->  ' + bridge
   return bridges

def generateVmConfig( qemuExec, vmName, networks , vmDir ):
   """ Generates a vmx file using the template located at templatePath with the
   arguments provided and writes it at outputPath """
   vmDir = vmDir + "/"
   imgFile = vmDir + 'EOS.qcow2'
   veosConfig = vmDir + vmName + '.xml'

   vmxBaseConfig = libvirtTemplate % ( vmName, qemuExec, imgFile )
   # insert network elements at the end of <devices>
   index = vmxBaseConfig.index("</devices>")
   vmxConfig = vmxBaseConfig[:index]
   # add interfaces in pci slots from 5
   for idx, net in enumerate( networks ):
      networkConfig = libvirtInterfaceTemplate % ( net, idx+5 )
      vmxConfig = vmxConfig + networkConfig
   vmxConfig = vmxConfig + vmxBaseConfig[index:]
   with open( veosConfig, 'w' ) as output:
      output.write( vmxConfig )
   return veosConfig

if __name__ == "__main__":
   checkIntelVt()

   ## get qemu path
   if os.path.isfile( "/usr/bin/qemu-system-x86_64" ):
      qemuExec = "/usr/bin/qemu-system-x86_64"
   elif os.path.isfile( "/usr/libexec/qemu-kvm" ):
      qemuExec = "/usr/libexec/qemu-kvm"
   else:
      sys.exit( "Unable to find qemu executable qemu-system-x86_64 or qemu-kvm" )

   vmDir = ""
   while True:
      vmName = raw_input( "Enter the name of the vEOS VM eg veosRouter : " )
      if not vmName:
         print "VM name cannot be empty string"
         continue
      if not checkCmd( ["virsh", "desc", vmName], None, errSubString="error" ):
         print "VM with name %s exists " % vmName
         continue
      break
   while True:
      imagePath = raw_input( "Enter the path of EOS.qcow2 image " )
      imagePath = os.path.abspath(os.path.expanduser(imagePath))
      if os.path.isfile(imagePath) is False:
         print "EOS.qcow2 not found at ", imagePath
         continue
      break
   while True:
      vmDir = raw_input( "Enter the path for storing VM image and template " )
      vmDir = os.path.abspath(os.path.expanduser(vmDir))
      if os.path.isdir(vmDir) is False:
         print "The VM path %s isn't found " % vmDir
         continue
      break

   vmDir = vmDir + "/" + vmName
   print "VM directory is ", vmDir
   runCmd( ['mkdir', vmDir ] )
   runCmd( ['cp', imagePath, vmDir] )

   devices = Devices()
   #print "Ethernet devices on host ", devices.ethDevices
   networks = setupNetworks( vmName )
   vmxConfigFile = generateVmConfig( qemuExec, vmName, networks, vmDir )
   cmdOutput( ["virsh", "define", vmxConfigFile] )
   cmdOutput( ["virsh", "start", vmName] )

